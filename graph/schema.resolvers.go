package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.22

import (
	"context"
	"encoding/json"
	"fmt"
	"pruebas/graph/model"
	"pruebas/prisma/db"
	"pruebas/service"
	"strconv"

	"github.com/99designs/gqlgen/graphql"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Login is the resolver for the login field.
func (r *authOpsResolver) Login(ctx context.Context, obj *model.AuthOps, email string, password string) (interface{}, error) {
	return service.UserLogin(ctx, email, password)
}

// Register is the resolver for the register field.
func (r *authOpsResolver) Register(ctx context.Context, obj *model.AuthOps, input model.NewUser) (interface{}, error) {
	return service.UserRegister(ctx, input)
}

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, input *model.PostInput) (*model.Post, error) {
	// Post res
	var Post *model.Post = nil

	// Connect to db
	client := db.NewClient()
	if err := client.Prisma.Connect(); err != nil {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: "unable to connect to database",
		})
	}

	defer func() {
		if err := client.Prisma.Disconnect(); err != nil {
			panic(err)
		}
	}()

	pctx := context.Background()

	// Post data
	createdPost, err := client.Post.CreateOne(
		db.Post.Title.Set(input.Title),
		db.Post.Desc.Set(input.Desc),
		db.Post.Content.Set(input.Content),
		db.Post.Published.Set(true),
	).Exec(pctx)
	if err != nil {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: "unable to create this post",
		})
	}

	// Print data
	result, _ := json.MarshalIndent(createdPost, "", "  ")
	fmt.Printf("created post: %s\n", result)

	// Append data if there's not an error
	if createdPost != nil {
		Post = &model.Post{
			ID:        createdPost.ID,
			Title:     createdPost.Title,
			Desc:      createdPost.Desc,
			Content:   createdPost.Content,
			CreatedAt: createdPost.CreatedAt.String(),
			UpdatedAt: createdPost.UpdatedAt.String(),
			Published: createdPost.Published,
		}

		print("CreatePost: Append data\n")
	}

	return Post, nil
}

// UpdatePost is the resolver for the updatePost field.
func (r *mutationResolver) UpdatePost(ctx context.Context, id int, input *model.PostInput) (*model.Post, error) {
	panic(fmt.Errorf("not implemented: UpdatePost - updatePost"))
}

// Auth is the resolver for the auth field.
func (r *mutationResolver) Auth(ctx context.Context) (*model.AuthOps, error) {
	return &model.AuthOps{}, nil
}

// GetPosts is the resolver for the GetPosts field.
func (r *queryResolver) GetPosts(ctx context.Context) ([]*model.Post, error) {
	// Posts
	var Posts []*model.Post = nil

	// Connect to db
	client := db.NewClient()
	if err := client.Prisma.Connect(); err != nil {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: "unable to connect to database",
		})
	}

	defer func() {
		if err := client.Prisma.Disconnect(); err != nil {
			panic(err)
		}
	}()

	pctx := context.Background()

	// Get data
	post, err := client.Post.FindMany(
		db.Post.Published.Equals(true),
	).Exec(pctx)
	if err != nil {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: "unable to find posts",
		})
	}

	// Error message
	if len(post) == 0 {
		print("no posts\n")
		graphql.AddError(ctx, &gqlerror.Error{
			Message: "no posts",
		})
	}

	// Append posts if there is data
	for i := 0; i < len(post); i++ {
		item := model.Post{
			ID:        post[i].ID,
			Title:     post[i].Title,
			Desc:      post[i].Desc,
			Content:   post[i].Content,
			CreatedAt: post[i].CreatedAt.String(),
			UpdatedAt: post[i].UpdatedAt.String(),
			Published: post[i].Published,
		}
		Posts = append(Posts, &item)
	}
	return Posts, nil
}

// GetOnePost is the resolver for the GetOnePost field.
func (r *queryResolver) GetOnePost(ctx context.Context, id int) (*model.Post, error) {
	// Post
	var Post *model.Post = nil

	// Connect to db
	client := db.NewClient()
	if err := client.Prisma.Connect(); err != nil {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: "unable to connect to database",
		})
	}

	defer func() {
		if err := client.Prisma.Disconnect(); err != nil {
			panic(err)
		}
	}()

	pctx := context.Background()

	// Get data
	post, err := client.Post.FindUnique(
		db.Post.ID.Equals(id),
	).Exec(pctx)
	if err != nil {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: "this post does not exist",
		})
	}

	// Append data if post is not null
	if post != nil {
		Post = &model.Post{
			ID:        post.ID,
			Title:     post.Title,
			Desc:      post.Desc,
			Content:   post.Content,
			CreatedAt: post.CreatedAt.String(),
			UpdatedAt: post.UpdatedAt.String(),
			Published: post.Published,
		}
		print("GeOnePost: Append data\n")
	}

	return Post, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	uid, _ := strconv.Atoi(id)
	return service.GetUserID(ctx, uid)
}

// Protected is the resolver for the protected field.
func (r *queryResolver) Protected(ctx context.Context) (string, error) {
	return "Success", nil
}

// AuthOps returns AuthOpsResolver implementation.
func (r *Resolver) AuthOps() AuthOpsResolver { return &authOpsResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type authOpsResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
type ErrMsg struct {
	ErrMsg string `json:"errmsg"`
}
